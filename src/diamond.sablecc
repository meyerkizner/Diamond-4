Package com.prealpha.diamond;


Helpers
	
	ascii_input_character = [0x00..0x7f];
	ht = 0x09;
	lf = 0x0a;
	ff = 0x0c;
	cr = 0x0d;
	sp = ' ';
	
	line_terminator = lf | cr | cr lf;
	input_character = [ascii_input_character - [cr + lf]];
	
	not_star = [input_character - '*'] | line_terminator;
	not_star_not_slash = [input_character - ['*' + '/']] | line_terminator;
	
	ascii_letter = [0x41..0x5a] | [0x61..0x7a];
	ascii_digit = [0x30..0x39];
	
	identifier_letter = ascii_letter | '$' | '_';
	identifier_letter_or_digit = ascii_letter | ascii_digit | '$' | '_';
	
	non_zero_digit = ['1'..'9'];
	digit = ['0'..'9'];
	hex_digit = ['0'..'9'] | ['a'..'f'] | ['A'..'F'];
	octal_digit = ['0'..'7'];
	binary_digit = '0' | '1';
	
	decimal_numeral = '0' | non_zero_digit digit*;
	hex_numeral = '0' ('x' | 'X') hex_digit+;
	octal_numeral = '0' octal_digit+;
	binary_numeral = '0' ('b' | 'B') binary_digit+;
	
	escape_sequence = '\b' | '\t' | '\n' | '\f' | '\r' | '\"' | '\' ''' | '\\';
	string_character = [input_character - ['"' + '\']] | escape_sequence;


Tokens
	
	// separators
	comma = ',';
	dot = '.';
	l_bkt = '[';
	l_brc = '{';
	l_par = '(';
	r_bkt = ']';
	r_brc = '}';
	r_par = ')';
	semi  = ';';
	
	// operators
	amp = '&';
	amp_amp = '&&';
	amp_assign = '&=';
	assign = '=';
	bar = '|';
	bar_assign = '|=';
	bar_bar = '||';
	caret = '^';
	caret_assign = '^=';
	caret_caret = '^^';
	colon = ':';
	emark = '!';
	eq = '==';
	gt = '>';
	gteq = '>=';
	lt = '<';
	lteq = '<=';
	minus = '-';
	minus_assign = '-=';
	minus_minus = '--';
	neq = '!=';
	percent = '%';
	percent_assign = '%=';
	plus = '+';
	plus_assign = '+=';
	plus_plus = '++';
	qmark = '?';
	shl = '<<';
	shl_assign = '<<=';
	shr = '>>';
	shr_assign = '>>=';
	slash = '/';
	slash_assign = '/=';
	star = '*';
	star_assign = '*=';
	
	// keywords
	abstract = 'abstract';
	boolean = 'boolean';
	break = 'break';
	case = 'case';
	catch = 'catch';
	class_token = 'class';
	const = 'const';
	continue = 'continue';
	default = 'default';
	delete = 'delete';
	do = 'do';
	double = 'double';
	else = 'else';
	enum = 'enum';
	extends = 'extends';
	final = 'final';
	finally = 'finally';
	float = 'float';
	for = 'for';
	goto = 'goto';
	if = 'if';
	implements = 'implements';
	instanceof = 'instanceof';
	int = 'int';
	interface = 'interface';
	long = 'long';
	native = 'native';
	new = 'new';
	private = 'private';
	protected = 'protected';
	raise = 'raise';
	repeat = 'repeat';
	return = 'return';
	short = 'short';
	static = 'static';
	super = 'super';
	switch = 'switch';
	this = 'this';
	throw = 'throw';
	throws_token = 'throws';
	try = 'try';
	virtual = 'virtual';
	void = 'void';
	while = 'while';
	yield = 'yield';
	
	// literals
	integral_literal = decimal_numeral | hex_numeral | octal_numeral | binary_numeral;
	string_literal = '"' string_character* '"';
	null_literal = 'null';
	true_literal = 'true';
	false_literal = 'false';
	
	// identifier
	identifier = identifier_letter identifier_letter_or_digit*;
	
	// whitespace and comments
	whitespace = (sp | ht | ff | line_terminator);
	block_comment = '/*' not_star+ '*'+ (not_star_not_slash not_star* '*'+)* '/';
	line_comment = '//' input_character* line_terminator?;


Ignored Tokens
	
	whitespace,
	block_comment,
	line_comment;


Productions
	
	program = top_level_statement*;
	top_level_statement =   {class} class_declaration |
							{function} function_declaration |
							{statement} statement;
	statement = {standalone_statement} standalone_statement |
				{if_then_statement} if_then_statement |
				{if_then_else_statement} if_then_else_statement |
				{while_statement} while_statement |
				{for_statement} for_statement |
				{repeat_statement} repeat_statement;
	standalone_statement =  {block} block |
							{empty} empty_statement |
							{expression} expression_statement |
							{switch} switch_statement |
							{do} do_statement |
							{delete} delete_statement |
							{break} break_statement |
							{continue} continue_statement |
							{return} return_statement;
	statement_no_short_if = {standalone} standalone_statement |
							{if_then_else_statement} if_then_else_statement_no_short_if |
							{while_statement} while_statement_no_short_if |
							{for_statement} for_statement_no_short_if |
							{repeat_statement} repeat_statement_no_short_if;
	
	class_declaration = class_token [name]:identifier class_body;
	class_body = l_brc class_statement* r_brc;
	class_statement =   {field} field_declaration |
						{function} function_declaration |
						{constructor} constructor_declaration;
	
	field_declaration = [modifiers]:field_modifier* [type]:type_token [name]:identifier semi;
	field_modifier =    {private} private |
						{static} static;
	
	function_declaration = [modifiers]:function_modifier* [return_type]:type_token [name]:identifier l_par [parameters]:formal_parameter_list? r_par block;
	constructor_declaration = [modifiers]:function_modifier* [return_type]:identifier new l_par [parameters]:formal_parameter_list? r_par block;
	formal_parameter_list = {simple} local_declaration |
							{compound} formal_parameter_list comma local_declaration;
	function_modifier = {private} private |
						{static} static;
	
	block = l_brc statement* r_brc;
	
	empty_statement = semi;
	
	expression_statement = statement_expression semi;
    statement_expression =  {assignment} assignment |
                            {pre_increment} pre_increment_expression |
                            {pre_decrement} pre_decrement_expression |
                            {post_increment} post_increment_expression |
                            {post_decrement} post_decrement_expression |
                            {function_invocation} function_invocation |
                            {constructor_invocation} constructor_invocation;

	if_then_statement = if l_par [condition]:expression r_par [if_body]:statement;
	if_then_else_statement = if l_par [condition]:expression r_par [if_body]:statement_no_short_if else [else_body]:statement;
	if_then_else_statement_no_short_if = if l_par [condition]:expression r_par [if_body]:statement_no_short_if else [else_body]:statement_no_short_if;
	
	switch_statement = switch l_par [value]:expression r_par switch_block;
    switch_block = l_brc switch_labels* r_brc;
	switch_labels = switch_label* statement+;
    switch_label =  case [value]:integral_literal colon |
                    {default} default colon;
	
	while_statement = while l_par [condition]:expression r_par statement;
	while_statement_no_short_if = while l_par [condition]:expression r_par statement_no_short_if;
	
	do_statement = do statement while l_par [condition]:expression r_par semi;
	
    for_statement = for l_par [init]:statement_expression? [semi1]:semi [condition]:expression? [semi2]:semi [update]:statement_expression? r_par statement;
    for_statement_no_short_if = for l_par [init]:statement_expression? [semi1]:semi [condition]:expression? [semi2]:semi [update]:statement_expression? r_par statement_no_short_if;
	
    repeat_statement = repeat l_par [repeat_count]:expression r_par statement;
    repeat_statement_no_short_if = repeat l_par [repeat_count]:expression r_par statement_no_short_if;
	
	delete_statement = delete identifier semi;
	
	break_statement = break semi;
	
	continue_statement = continue semi;
	
	return_statement = return [return_value]:expression? semi;
	
	primary_expression =    {literal} literal |
							{this} this |
							{parenthetical} l_par expression r_par |
							{function_invocation} function_invocation |
							{constructor_invocation} constructor_invocation |
							{field_access} field_access |
							{array_access} array_access;
	literal =   {integral} integral_literal |
				{string} string_literal |
				{null} null_literal |
				{true} true_literal |
				{false} false_literal;

	member_access_prefix =  {identifier_member} identifier dot |
							{expression_member} primary_expression dot |
							{type_token_member} type_token dot;
	
	function_invocation = [target]:member_access_prefix? basic_function_invocation;
	basic_function_invocation = [function_name]:identifier l_par actual_parameter_list? r_par;
	constructor_invocation =    {implied_target} basic_constructor_invocation |
								{type_token_target} type_token dot basic_constructor_invocation;
	basic_constructor_invocation = new l_par actual_parameter_list? r_par;
	actual_parameter_list = {simple} expression |
                            {compound} actual_parameter_list comma expression;
	
	field_access =  [target]:member_access_prefix [field_name]:identifier;
	
	array_access =  {named_target} [target]:identifier l_bkt [index]:expression r_bkt |
					{expression_target} [target]:primary_expression l_bkt [index]:expression r_bkt;
	
	postfix_expression =    {primary} primary_expression |
							{identifier} identifier |
							{post_increment} post_increment_expression |
							{post_decrement} post_decrement_expression;
	post_increment_expression = postfix_expression plus_plus;
	post_decrement_expression = postfix_expression minus_minus;
	
	unary_expression =  {pre_increment} pre_increment_expression |
						{pre_decrement} post_increment_expression |
						{unary_plus} plus unary_expression |
						{unary_minus} minus unary_expression |
						{logical_not} emark unary_expression |
						{postfix} postfix_expression;
	pre_increment_expression = plus_plus unary_expression;
	pre_decrement_expression = minus_minus unary_expression;
	
	multiplicative_expression = {unary} unary_expression |
								{multiplication} multiplicative_expression star unary_expression |
								{division} multiplicative_expression slash unary_expression |
								{modulus} multiplicative_expression percent unary_expression;
	
	additive_expression =   {multiplicative} multiplicative_expression |
							{addition} additive_expression plus multiplicative_expression |
							{subtraction} additive_expression minus multiplicative_expression;
	
	shift_expression =  {additive} additive_expression |
						{shift_left} shift_expression shl additive_expression |
						{shift_right} shift_expression shr additive_expression;
	
	relational_expression = {shift} shift_expression |
							{less_than} relational_expression lt shift_expression |
							{greater_than} relational_expression gt shift_expression |
							{less_or_equal} relational_expression lteq shift_expression |
							{greater_or_equal} relational_expression gteq shift_expression;
	
	equality_expression =   {relational} relational_expression |
							{equals} equality_expression eq relational_expression |
							{not_equals} equality_expression neq relational_expression;
	
	bitwise_and_expression =    {equality} equality_expression |
								{bitwise_and} bitwise_and_expression amp equality_expression;
	bitwise_xor_expression =    {bitwise_and} bitwise_and_expression |
								{bitwise_xor} bitwise_xor_expression caret bitwise_and_expression;
	bitwise_or_expression =     {bitwise_xor} bitwise_xor_expression |
								{bitwise_or} bitwise_or_expression bar bitwise_xor_expression;
	
	conditional_and_expression =    {bitwise_or} bitwise_or_expression |
									{conditional_and} conditional_and_expression amp_amp bitwise_or_expression;
	conditional_xor_expression =    {conditional_and} conditional_and_expression |
									{conditional_xor} conditional_xor_expression caret_caret conditional_and_expression;
	conditional_or_expression =     {conditional_xor} conditional_xor_expression |
									{conditional_or} conditional_or_expression bar_bar conditional_xor_expression;
	
	conditional_expression =    {conditional_or} conditional_or_expression |
								{conditional} conditional_or_expression qmark expression colon conditional_expression;
	
	assignment_expression = {conditional} conditional_expression |
							{assignment} assignment;
	assignment = left_hand_side assignment_operator assignment_expression;
	left_hand_side =    {local_declaration} local_declaration |
						{identifier} identifier |
						{field_access} field_access |
						{array_access} array_access;
	local_declaration = type_token identifier;
	assignment_operator =   {assign} assign |
							{star_assign} star_assign |
							{slash_assign} slash_assign |
							{percent_assign} percent_assign |
							{plus_assign} plus_assign |
							{minus_assign} minus_assign |
							{shl_assign} shl_assign |
							{shr_assign} shr_assign |
							{amp_assign} amp_assign |
							{bar_assign} bar_assign |
							{caret_assign} caret_assign;
	
	expression = assignment_expression;
	
	type_token =    {boolean} boolean |
					{short} short |
					{int} int |
					{long} long |
					{identifier} identifier |
					{array} type_token l_bkt r_bkt;

